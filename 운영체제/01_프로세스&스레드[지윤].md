## **프로세스(Process)**

<img src="https://user-images.githubusercontent.com/64777557/220025409-ed4ea68a-3413-4994-b405-46aa325c72d5.png" width=800>

-   프로그램이 메모리로 올라와 운영체제로부터 CPU를 할당받고 실행되고 있는 상태
-   CPU 스케줄링의 대상이 되는 작업의 흐름을 지칭
-   하나의 프로그램(애플리케이션)은 하나 이상의 프로세스를 가짐
-   각 프로세스는 별도의 주소 공간에서 실행되고 프로세스끼리 지원을 공유하지 않기 때문에 다른 프로세스의 변수나 자료구조에 접근할 수 없음
-   프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap)을 할당 받음

</br></br>

## **스레드(Thread)**

<img src="https://user-images.githubusercontent.com/64777557/220025540-bf8aab79-0038-49f8-9b3d-71a5f48aa9e0.png" width=800>


-   프로세스 내에서 실행되는 흐름의 단위
-   하나의 프로세스는 하나 이상의 스레드를 가짐
-   각각의 스레드는 프로세스 내에서 Stack 영역만 따로 할당받고 Code, Data, Heap 영역은 서로 공유함

</br></br>

## **멀티프로세스(Multi-Process)**

![image](https://user-images.githubusercontent.com/64777557/220025690-6664163a-8e04-40fa-8c49-d5a3c37a2b45.png)

-   하나의 애플리케이션을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하도록 하는 것
-   각각의 프로세스는 서로 공유하는 자원이 없음

**장점**

-   여러 개의 자식 프로세스 중 하나에 문제가 발생하면 해당 프로세스만 죽는 것으로 다른 프로세스에게 영향을 주지 않음 (독립적)

**단점**

-   Context Switching(문맥교환) 오버헤드
    -   각각의 자식 프로세스는 독립된 메모리 영역을 할당받았기 때문에 문맥 교환 시 캐시에 있는 모든 데이터를 리셋하고 다시 캐시 정보를 불러와야 함
    -   캐시 메모리 초기화 등 무거운 작업은 문맥 교환 과정에서 오버헤드가 발생하는 원인이 됨
-   프로세스 간 통신 기법(IPC) 필요
    -   한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간 통신(IPC)을 사용해야함
    -   예) 파이프, 소켓 등

> 💡**Context Switching(문맥교환) 란?**  
> 한 번에 한 가지 작업밖에 처리하지 못하는 CPU의 특성에도 한 번에 여러 개의 프로세스나 스레드가 실행되는 것처럼 보이기 위해 여러 프로세스/스레드를 짧은 단위로 번갈아가며 실행해주어야 한다. 이때, 실행 중이던 프로세스/스레드를 중단하고 다른 프로세스/스레드를 실행하는 것을 Context Switching(문맥 교환)이라고 한다.

</br></br>

## **멀티스레드(Multi-Tread)**

![image](https://user-images.githubusercontent.com/64777557/220025737-db07c672-4788-49e1-b446-c775824e8995.png)

-   하나의 애플리케이션을 여러 개의 스레드로 구성하여 각 스레드가 하나의 작업을 처리하도록 하는 것
-   각각의 스레드는 Stack을 제외한 모든 자원을 공유

**장점**

-   시스템 자원의 소모 감소
    -   프로세스 생성을 통해 자원을 할당하는 시스템 콜이 줄어 자원을 효율적으로 사용 및 관리할 수 있음
    -   스레드 간 데이터를 주고받는 일이 간단해 시스템 자원 소모 적음
-   시스템 처리량 증가, 비용 감소 (Context Switching 오버헤드 감소) 
    -   Stack을 제외한 자원을 공유하여 CPU 스케줄링 과정 Context Switching(문맥 교환) 시 비용과 부담이 적음
-   간단한 통신 방법으로 프로그램 응답 시간 단축
    -   IPC와 같은 복잡한 통신 기법을 사용하지 않아 통신의 부담이 적음

**단점**

-   동기화 문제
    -   여러 스레드가 동시에 하나의 자원에 접근하는 경우에 대한 문제 발생
-   여러 개의 스레드 중 하나에 문제가 발생하면 해당 스레드 뿐만 아니라 다른 스레드의 작업에도 영향을 줌
    -   프로세스 자체를 중단해야 함
-   구현, 테스트, 디버깅이 어려움

</br></br>

### **⭐️ 참고**

-   [https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html](https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html)
-   [https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4](https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4)
