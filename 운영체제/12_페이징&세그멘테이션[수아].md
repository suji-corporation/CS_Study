### 가상 메모리 관리 기법 - 페이징과 세그멘테이션  
- `가상 메모리` : 실행중인 프로세스가 가상의 공간을 참조하여 마치 커다란 물리 메모리를 갖고 있는 것처럼 사용할 수 있게 하는 것 
- 실제 메모리 주소가 아닌 가상의 메모리를 주는 방식 
- 가상 메모리는 각 프로세스 당 메인 메모리와 동일한 크기로 하나씩 할당됨 (보조기억장치 공간 사용) 
- MMU(메모리 관리 장치)에 의해 물리 주소로 변환됨 

## 연속 할당 
- 각각의 프로세스가 메모리의 연속적인 공간에 적재되도록 하는 방법 
- ex) 
  - 고정 분할 방식 : 물리적 메모리를 고정적 partition으로 나누는 것. 분할 당 하나의 프로그램 적재
  - 가변 분할 방식 : 프로그램의 크기를 고려해서 할당. 분할의 크기, 개수가 동적으로 변환 

## 불연속 할당 
- 하나의 프로세스가 메모리의 여러 영역에 분산되어 할당하는 방법 
- ex) 페이징, 세그멘테이션, Paged Segmentation 

</br> 

## 페이징(Paging) 
![image](https://user-images.githubusercontent.com/63537847/225213290-2a938183-fe4c-40cc-9d1c-52897d4c8b84.png)

- 프로세스의 주소 공간을 동일한 사이즈의 페이지 단위로 나눠 **물리적 메모리**에 **불연속적**으로 저장하는 방식 
  - 프로세스 : `Page`라는 고정 크기로 분할 
  - 메모리 : `Frame`이라는 고정 크기로 분할 
- 작은 조각들이 여기저기 흩어져 있기 때문에 MMU를 통해 물리 주소와 논리 주소로 나눠 CPU를 속이게 됨 
- 실제로는 연속적이지 않지만 CPU는 연속적으로 사용하고 있다는 것을 보장받음 

#### 🔵 장점 
1. 외부 단편화가 없음 
2. 메모리 공간 활용도 향상 

#### 🔴 단점 
1. 페이지가 클 수록 **내부 단편화** 문제의 비중 증가 
2. 페이지 교체 오버헤드 
3. 메모리 접근 시간 증가 

### 페이징의 보호와 공유 
#### 보호
![image](https://user-images.githubusercontent.com/63537847/225216929-80455801-2f5b-4339-b677-9631bdc2eda0.png)

- 모든 주소는 페이지 테이블을 경유하기 때문에 테이블을 이용해서 보호 기능을 수행할 수 있음 
- r, w, x 비트가 있음 
- 페이징은 code+data+stack을 일정한 크기로 나눠 영역이 섞일 수 있음 → 비트 설정하기 까다로움 
- 켜지지 않은 비트에 해당되는 작업을 수행하면 강제로 프로세스 종료 (CPU 인터럽트) 
#### 공유 
- 메모리 낭비 방지하기 위함 
- 하나의 코드 영역을 여러 프로세스가 공유 (다른 영역도 포함될 수 있음)
- BUT 변하지 않는 코드여야 함 

</br>

## 세그멘테이션(Segemtation)
![image](https://user-images.githubusercontent.com/63537847/225213790-77d6d0fa-3a85-47c6-af03-357f07f780bd.png)

- 논리적 단위(세그멘트)로 나눠서 메모리에 배치되는 것 
- 미리 분할하지 않고 메모리 사용할 시점에 할당됨 
- 세그멘트의 크기는 일정하지 않음 
- 세그멘트를 메모리에 할당하는 것은 페이지 할당과 동일 
- `세그멘트 테이블`
  - 번호(s), 시작 주소(base), 세그멘트 크기(limit)로 이루어짐 
  - limit : 세그멘트 크기 일정하지 않아서 필요. 크기 넘는 주소가 들어오면 인터럽트 발생해서 강제 종료됨 


#### 🔵 장점 
1. 내부 단편화가 없음 
2. 메모리 사용 효율 개선 

#### 🔴 단점 
1. 외부 단편화 문제 발생 가능 

### 페이징의 보호와 공유 
- 페이징보다 효과적 
#### 보호 
- r, w, x 비트가 있음 
- 논리적으로 나누기 때문에 비트를 설정하기 간단하고 안전 
#### 공유
- 정확히 code 영역만 나눠서 효율적

</br> 

## 페이징 vs 세그멘테이션
- 현재는 대부분 페이징 사용 
  - 논리적인 단위로 나누기 때문에 크기가 다양하고 여러 크기의 hole이 발생하기 때문 
- 세그멘테이션은 보호와 공유에서 효율적
- 페이징은 외부 단편화 문제 해결 
- 두 장점을 합친 `Paged Segmentaion` 기법이 있지만 주소 변환을 2번 해야 한다는 단점 존재 

</br>
</br>

> 참고      
> https://dar0m.tistory.com/269           
> 
