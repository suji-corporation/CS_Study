> 💡**단편화(Fragmentation)란?**  
> 메모리 공간이 부분으로 나뉘어서 충분히 사용 가능한 메모리가 남아있지만, 프로세스 할당이 불가능한 상태

</br>

## **내부 단편화(Internal Fragmentation)**

-   프로세스가 필요한 양보다 더 큰 메모리가 할당되어 메모리 공간 낭비 발생
-   프로세스는 실제로 사용하지 않는 메모리 영역을 가지고 있게 됨

#### **Ex) 100MB의 메모리에 80MB 크기의 프로세스 적재**

![image](https://user-images.githubusercontent.com/64777557/224632329-96eb32bc-364e-4d3c-af38-7a0666597fa4.png)

다음과 같은 20MB의 내부 단편화 발생 (해당 메모리 사용 불가)

![image](https://user-images.githubusercontent.com/64777557/224632405-2fc24376-7666-4233-94ca-6c8e6790e685.png)

</br></br>

## **외부 단편화(External Fragmentation)**

-   남아있는 총 메모리 공간이 프로세스가 요청한 메모리 공간보다 크지만, 남아있는 공간이 연속적이지 않아 사용할 수 없는 경우
-   쪼개진 메모리 공간을 사용할 수 없어 메모리 낭비 발생
-   프로세스들이 메모리를 할당하고 반납하는 과정에서, 사용할 수 있는 메모리 공간이 쪼개져서 발생

#### **Ex) 100(50+50)MB 남아있는 메모리 공간에 80MB 프로세스 적재**

![image](https://user-images.githubusercontent.com/64777557/224632458-55c1f7a8-bb0a-4182-9030-4133ab5acaa1.png)

남아있는 메모리 공간은 50MB+50MB =100MB로 요청한 메모리 공간 80MB보다 크지만, 남아있는 공간이 연속적이지 않아 Process C를 할당할 수가 없게됨

</br></br>

## **메모리 단편화 해결방법**

#### **1\. 압축 (외부 단편화 해결)**

![image](https://user-images.githubusercontent.com/64777557/224632487-d253bb94-8e77-475f-8bb7-e9246e21ab31.png)

-   메모리 재배치를 통해 분산(단편화)되어 있는 공간들을 하나로 합치는 기법

#### **2\. 통합 (외부 단편화 해결)**

-   단편화로 인해 분산된 메모리 공간들 중 인접해 있는 공간끼리 통합시켜 큰 메모리 공간으로 합치는 기법
-   압축은 재배치가 일어나지만 통합은 인접한 공간끼리 합해진다는 차이

#### **3\. 페이징 (외부 단편화 해결)**

-   프로세스의 가상 메모리를 고정 크기의 블록인 페이지(page) 단위로 분할하여 물리 메모리에 할당하는 기법
-   페이지들은 논리적으로 연속적인 공간으로 할당되지만, 물리적으로는 분산되어 할당
-   페이지 단위로 분할되어 할당되기 때문에 물리 메모리 내에 작은 공간이 남더라도 이를 페이지 크기로 합쳐 큰 공간으로 사용할 수 있기 때문에 외부 단편화 해결

#### **4\. 세그멘테이션 (내부 단편화 해결)**

-   프로세스의 가상 메모리를 서로 다른 크기의 블록인 세그먼트(Segment) 단위로 분할하여 물리 메모리에 할당하는 기법
-   프로세스의 크기가 동적으로 변하는 경우에 효율적으로 메모리를 할당할 수 있어 내부 단편화 해결

#### **5\. 메모리 풀 (내부+외부 단편화 해결)**

-   필요한 메모리 크기와 개수를 지정해 미리 할당을 받아 메모리 풀을 만들어 놓고 필요할 때마다 사용하고 반납
-   할당받았던 메모리 공간을 가져다 쓰고 반납하기 때문에 메모리 할당과 해제로 인한 외부 단편화가 생기지 않음
-   필요한 크기만큼 할당을 해놓기 때문에 내부 단편화 또한 생기지 않음
-   메모리 단편화로 인한 메모리 낭비량보다 메모리 풀을 만들었지만 쓰이지 않는 메모리의 양이 큰 경우에는 사용하지 않아야 함
-   미리 할당해 놓고 사용하지 않는 순간에도 역시 메모리 누수가 일어나는 것이므로 잦은 동적할당과 해제가 일어날 경우에 사용하는 것이 바람직

</br></br>

### **⭐️ 참고**

-   [https://code-lab1.tistory.com/54](https://code-lab1.tistory.com/54)
-   [https://gguljaem.tistory.com/entry/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8B%A8%ED%8E%B8%ED%99%94Fragmentation%EC%97%90-%EB%8C%80%ED%95%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95](https://gguljaem.tistory.com/entry/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8B%A8%ED%8E%B8%ED%99%94Fragmentation%EC%97%90-%EB%8C%80%ED%95%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95)
