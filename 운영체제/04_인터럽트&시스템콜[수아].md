## 커널 모드(Kernel Mode)와 사용자 모드(User Mode)
하드웨어적인 보안은 유지하기 위해 2가지 모드로 운영               
CPU 내부의 mode bit으로 구분 (0* : 커널 모드 / 1* : 사용자 모드)

![image](https://user-images.githubusercontent.com/63537847/220831420-f8b8768e-c2a0-450b-9498-9c18396dad83.png)


### 커널 모드(Kernel Mode)
- `OS`가 존재하는 부분을 PC register가 가리키고 있는 경우 
- 운영체제에서 코드 실행중인 상태 
- CPU는 커널 모드에서 수행중 
- `모든 종류의 명령` 다 실행할 수 있음 

### 사용자 모드(User Mode)
- 사용자가 올라가 있는 `메모리의 위치`를 PC register가 가리키고 있는 경우 
- 사용자가 프로그램 수행중인 상태 
- CPU는 유저 모드에서 수행중
- `제한적인 명령`만 수행 (시스템에 중요한 영향을 미치는 연산 ❌) 

</br> 

## 인터럽트(Interrupt) 
### ❓ 인터럽트란? 
- 시스템에서 발생한 다양한 종류의 이벤트 혹은 그런 이벤트를 알리는 메커니즘 
- CPU가 프로그램을 실행하고 있을 때, 예외상황이 발생하여 처리가 필요한 경우 마이크로프로세서에 알려 처리할 수 있도록 하는 것 
- CPU 내에 있는 `인터럽트 라인` 세팅해서 인터럽트 발생시킴 
  ⇒ CPU는 매번 명령 수행하기 전에 인터럽트 라인이 세팅되어있는지 확인함 

#### 💡 종류 
1. 하드웨어 인터럽트 
    - 하드웨어가 발생시키는 인터럽트 
    - CPU가 아닌 다른 하드웨어 장치가 CPU에 어떤 사실을 알려주거나 CPU 서비스 요청할 경우 발생 
    - CPU의 `하드웨어 신호`에 의해 발생 
2. 소프트웨어 인터럽트 
    - 소프트웨어가 발생시키는 인터럽트 
    - 스스로 인터럽트 라인을 세팅 ex)예외, system call 
    - `명령어의 수행`에 의해 발생 

### 인터럽트 발생 처리 과정 
> ex) process A 실행 중 디스크에서 데이터를 읽어오라는 명령을 받았을 때 
1. process A가 `system call`을 통해 인터럽트 발생시킴 
2. CPU가 진행하던 코드를 중지함 
3. 멈춘 상태를 process의 PCB(Process Control Block)에 저장 
4. PC(Program Counter, IP)에 다음에 실행할 명령의 주소를 저장
5. 인터럽트 벡터를 읽고 ISR 주소값을 얻어 ISR(Interrupt Service Routine)로 점프하여 루틴을 실행
6. 해당 코드를 실행하고 일을 다 처리하면, 대피시킨 레지스터를 복원
7. ISR의 끝에 IRET 명령어에 의해 인터럽트가 해제
8. 대피시킨 PC값 복원해서 이전 실행 위치로 복귀

![image](https://user-images.githubusercontent.com/63537847/220826845-c1038dbb-7f1a-4e97-b405-342c6c0793c9.png)

## MCU(마이크로프로세서)에서 입력 받아들이는 방법 
- CPU(프로세서)와 입출력 장치의 통신 방식 
### 1️⃣ 폴링 방식 
- 특정 주기마다 스레드 돌면서 시그널 여부 확인하는 방식 
- 소프트웨어적으로 시그널 확인
- 인터럽트 요청 플래그를 차례로 비교하여 우선순위가 가장 높은 인터럽트 자원을 찾아 이에 맞는 인터럽트 서비스 루틴을 수행

🔵 **장점** 
1. 구현이 쉬움 
2. 우선순위 변경 용이 

🔴 **단점** 
1. 폴링을 하는 시간에는 원래 하던 일에 집중할 수가 없게 되어 많은 기능을 제대로 수행하기 어려움 
2. 리소스를 많이 먹음 
3. 특정 주기마다 확인하기 때문에 시그널이 들어오는 정확한 타이밍을 모름 

### 2️⃣ 인터럽트 방식 
- 외부의 인터럽트 핀에 신호가 들어오면 즉시 인터럽트 소스 실행한 뒤 바로 원래의 코드로 돌아오는 방식 
- 하드웨어적으로 시그널 확인 
- 신속하게 대응하기 때문에 실시간 대응이 필요한 경우에는 필수적인 기능 
- 커널의 interrupt handler가 인터럽트 확인하고, interrupt thread에 발생했다고 알려줌 

🔵 **장점** 
1. 시그널이 들어온 정확한 타이밍 알 수 있음 (빠른 반응 시간)
2. 시스템 부하 적음 (인터럽트 발생했을 때만 처리해서) 

🔴 **단점** 
1. 구현이 복잡함

</br>

## 시스템콜(System Call) 
### ❓ 시스템콜이란? 
- 프로그램이 OS 커널이 제공하는 서비스를 이용(하드웨어에 직접 접근)하고 싶을 때 시스템 콜을 통해 실행  
- 시스템콜은 여러 종류의 기능이 있음 
- 각 시스템 콜은 번호가 할당되고 시스템콜 인터페이스는 번호와 시스템콜 핸들러 함수의 주소로 구성되는 테이블을 유지함 
- 작업이 완료되면 CPU에 인터럽트 발생시켜 수행 완료됨 알림 

### 추가 정보 매개변수 OS에 전달하는 방법 
1. 매개변수 CPU 레지스터 내에 전달 (BUT 매개변수 개수가 레지스터 개수보다 많을 수 있음) 
2. 매개변수를 메모리에 저장 → 메모리 주소가 레지스터에 전달 
3. 프로그램에 의해 stack으로 push 
> 매개변수의 개수나 길이에 제한이 없기 때문에 2번, 3번 방식 선호 

### 시스템콜 유형 
1️⃣ 프로세스 제어(Process Control)           
   
   - 프로세스 생성 및 종료
   - 메모리에 로드, 실행
   - 프로세스 속성 값 확인, 지정
   - wait 이벤트, signal 이벤트
   - 메모리 할당

2️⃣ 파일 조작(File Manipulation)        
 
   - 파일 생성, 파일 삭제
   - 열기, 닫기
   - 읽기, 쓰기, Reposition
   - 파일 속성 값 확인, 지정  

3️⃣ 장치 관리(Device Management)           

   - 디바이스 요청 및 해제
   - 읽기, 쓰기, Reposition
   - 디바이스 속성 확인, 지정
   - 비 물리적인 디바이스 해제 및 장착 

4️⃣ 정보 유지(Information Maintenance)           

   - 시간 확인, 시간 지정
   - 시스템 데이터 확인, 지정
   - 프로세스, 파일, 디바이스 속성 가져오기
   - 프로세스, 파일, 디바이스 속성 설정하기

5️⃣ 통신(Communication)           

   - 커뮤니케이션 연결 생성 및 삭제
   - 메시지 송신, 수신
   - 상태 정보 전달
   - remote 디바이스 해제 및 장착

6️⃣ 보안(Security)          

   - Permission 획득
   - Permission 설정


</br>
</br>

> 참고             
> https://velog.io/@adam2/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8              
> https://kkhipp.tistory.com/155           
> https://gyoogle.dev/blog/computer-science/operating-system/Interrupt.html            
> https://luckyyowu.tistory.com/133                 
> https://kosaf04pyh.tistory.com/196
