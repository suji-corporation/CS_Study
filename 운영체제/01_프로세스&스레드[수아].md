**프로그램** : 어떤 작업을 라기 위해 실행할 수 있는 파일 or 프로그램                  
**프로세스** : 메모리에 적재되서 CPU 자원을 할당받아 프로그램이 진행되고 있는 상태 

## 프로세스(Process) 

![image](https://user-images.githubusercontent.com/63537847/220013520-113a71b3-b301-4cc0-8a6d-a9066022171f.png)

- `컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램`
- OS로부터 시스템 자원 할당받는 작업의 단위 
- CPU 스케줄링의 대상이 되는 작업(task) 
- 프로그램이 메모리에 올라가면 프로세스가 됨(= 인스턴스화) 

💡 **특징** 
1. 프로세스 각각 독립된 메모리 영역(Code, Data, Stack, Heap)을 할당 받음
2. 기본적으로 1개의 프로세스는 1개의 스레드를 가짐 
3. 각 프로세스는 별도의 주소 공간에서 실행 됨 ⇒ 다른 프로세스의 메모리에 접근할 수 ❌
4. 다른 프로세스에 접근하기 위해서는 프로세스 간 통신(IPC) 사용해야 함 

### 프로세스 메모리 구조 
**1️⃣ Code**                   
- 프로그램에 내장된 코드 영역  
- 수정 불가능한 기계어로 저장 
- 정적 영역 

**2️⃣ Data**                  
- 전역변수, 정적변수 저장됨 
- 정적인 특징 갖는 프로그램 종료되면 사라지는 변수다 저장된 영역 
- 정적 영역

**3️⃣ Stack**                   
- 지역변수, 매개변수, 함수 저장됨 
- **컴파일** 시 크기 결정됨 
- 함수를 재귀호출하면서 크기가 늘어날 수 있는데 `Heap` 영역과 겹치지 않기 위해 사이 공간을 비워놓음
- 동적 영역

**4️⃣ Heap**                      
- 동적 할당할 때 사용 
- **런타임** 시 크기 결정됨 
- 동적 영역 

### 프로세스 제어 블록(PCB : Process Control Block) 
![image](https://user-images.githubusercontent.com/63537847/220021485-3d5aa03c-faf0-4302-868a-dfd7b91a5cba.png)

- 운영체제에서 프로세스에 대한 `메타데이터`를 저정한 데이터 
  - `메타데이터` : 데이터를 설명하는 작은 데이터
- 프로세스가 생성되면 운영체제는 해당 PCB 생성 
- context switching은 PCB를 교환하는 과정 

</br>

## 멀티 프로세스(Multi Process)

<img width="300" alt="image" src="https://user-images.githubusercontent.com/63537847/220017152-fba840a2-f1cc-4323-afff-fcc5e95ee901.png">

- 하나의 애플리케이션을 여러 프로세스로 구성하여 동시에 2가지 이상의 일을 수행하는 것 
- 하나 이상의 일 병렬로 처리 가능 
- 특정 프로세스에 문제가 생겨도 다른 프로세스를 사용할 수 있어서 신뢰성 높음 

💡 **특징** 
1. 안전성 ⬆️ : 하나의 프로세스에 문제가 발생해도 다른 자식 프로세스에 영향 확산되지 않음
2. 간단한 구현 
3. 독립적인 동작 
4. 메모리 사용량 ⬆️
5. 스케줄링에 따른 context switching이 많아져 성능 저하될 수 있음 
6. 프로세스 간에 통신을 위해서는 IPC 통해서 해야 함 

</br>

## 스레드(Thread)

![image](https://user-images.githubusercontent.com/63537847/220014899-9e726647-4aee-47ed-9bf5-0a774e463a5a.png)

- `프로세스 내 작업의 흐름 (여러 흐름의 단위)`
- 프로세스가 할당 받은 자원을 이용하는 실행의 단위

💡 **특징** 
1. 프로세스 내에서 각각 stack만 따로 할당 받고 나머지 메모리 영역(Code, Data, Heap)은 공유 
2. 프로세스 내의 자원과 주소 공간을 동일 프로세스 내 스레드와 공유하면서 실행됨 
3. 각각의 스레드는 별도의 레지스터와 스택을 갖지만 heap 메모리는 서로 읽고 쓸 수 있음 
4. 한 스레드가 프로세스의 자원을 변경하면, 다른 스레드도 즉시 변경한 결과 확인 가능 

❓ **스레드는 왜 탄생했을까?**             
→ 프로세스보다 크기가 작은 실행단위 필요했고, 프로세스는 생성하거나 소멸할 때 큰 오버헤드가 있어 이를 줄이기 위해 탄생했다.                         
  또한 프로세스들 사이에는 통신이 어려워 더 쉬운 방식이 필요했다.              
  프로세스는 context switching이 비효율적이고 오베헤드가 커서 빠르게 문맥교환을 하기 위해 스레드가 탄생했다. 

</br>

## 멀티 스레드(Multi Thread) 

![image](https://user-images.githubusercontent.com/63537847/220017922-e9acb7ae-5c81-4562-937f-3edc61c02e2f.png)

- 프로세스 내 작업을 여러 개의 스레드로 처리하는 방법 
- 하나의 스레드가 하나의 작업을 처리하도록 

💡 **특징** 
1. 응답성 좋음 : 프로그램의 일부 스레드가 중단되어도 프로그램을 계속 실행할 수 있음
2. 자원 공유 쉬움 ⇒ 효율성 높음
3. 프로세스 할당하는 것보다 스레드 할당하는 것이 비용이 적음
4. 멀티프로세서 구조에서 각각의 스레드가 다른 프로세스에서 병렬로 수행 가능 
5. 구현/테스트/디버깅 어려움
6. 잦은 사용을 오베헤드 초래할 수 있음
7. 동기화 or 교착상태 발생할 수 있음
8. 자식 스레드 중 하나에 문제가 생기면 전체 프로세스 영향줄 수 있음


</br> 

## 멀티 프로세스 vs 멀티 스레드 
|| 멀티 프로세스 | 멀티 스레드 |
|---|---|---|
|장점|하나의 프로세스가 죽어도 다른 프로세스에는 영향 ❌|프로세스 응답시간 단축/시스템 처리율 ⬆️ </br> 자원 소모 적음|
|단점|독립된 메모리 영역을 갖고 있어 작업량 많으면 오베헤드 발생 </br> context switching으로 인한 성능 저하|디버깅 어려움 </br> 하나의 스레드에 문제 생기면 전체적인 프로세스에 영향|



</br>
</br>

> 참고                    
> https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html                     
> https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4              
> https://lazymankook.tistory.com/32               
