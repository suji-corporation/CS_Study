## **인덱스(Index)**

![image](https://user-images.githubusercontent.com/64777557/226274822-fc8d6aeb-ce87-4ac2-a583-1ab061d8a203.png)

-   책의 '색인'과 같이 데이터베이스 내 데이터 검색 성능을 높이기 위해 사용하는 자료 구조
-   특정 칼럼에 인덱스를 생성하면, 해당 칼럼의 데이터를 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장
-   데이터를 검색하는 쿼리를 실행하면 옵티마이저는 인덱스에 저장되어 있는 데이터의 물리 주소를 참조하면서 검색 속도 향상
-   인덱스 생성 시 데이터를 오름차순으로 정렬

#### **장점**

-   **검색 조건 WHERE 절에서의 효율성**
    -   인덱스를 설정하지 않으면 뒤죽박죽 섞여있는 데이터 중 검색을 하려면 풀 스캔(Full Scan)을 해야함
    -   인덱스 테이블은 데이터들이 정렬되어 저장되어 있기 때문에 조건(WHERE절)에 맞는 데이터를 빠르게 찾을 수 있음
-   **정렬 ORDER BY 절에서의 효율성**
    -   인덱스를 사용하면 이미 정렬되어 있기 때문에 ORDER BY에 의한 정렬 과정을 피할 수 있어 시스템 부하를 줄일 수 있음
-   **MIN과 MAX의 처리 효율성**
    -   인덱스를 사용하면 데이터가 정렬되어 있기 때문에 MIN값과 MAX값은 각각 시작 값과 끝 값을 의미하여 풀 스캔(Full Scan)으로 처리하는 것보다 효율적으로 동작

#### **단점**

-   **인덱스를 위한 추가 저장 공간 필요**
    -   인덱스를 저장하고 관리하기 위해서는 데이터베이스의 약 10%에 해당하는 저장 공간이 추가로 필요함
-   **DML(INSERT, UPDATE, DELETE) 명령에 취약**
    -   INSERT, UPDATE, DELETE 등 DML 명령어를 실행하면 인덱스 테이블 내 데이터를 다시 정렬하는 과정이 필요함
    -   원본 테이블 뿐만 아니라 인덱스 테이블 또한 삽입/수정/삭제를 반영해야하므로 DML이 빈번하게 발생하면 부하 발생
-   **잘못 사용할 경우 오히려 성능 저하**  
    -   테이블의 전체 데이터 중에서 10~15% 이하의 데이터를 처리하는 경우 즉, 테이블에 데이터가 많은 경우에만 효과적
    -   데이터가 적을 때는 인덱스가 괜히 저장 공간만 차지할 뿐 풀 스캔이 더욱 빠르게 동작

</br></br>

## **인덱스 생성 전략**

-   데이터의 삽입/수정/삭제 작업이 많이 일어나지 않고 데이터 조회 및 검색 작업이 빈번히 일어나는 테이블

1.  조건 절에 자주 등장하는 칼럼
2.  조건 절에서=(같음) 연산자로 비교되는 칼럼
3.  ORDER BY 절에서 정렬의 기준으로 쓰이는 칼럼
4.  중복 데이터 발생 확률이 최소인 칼럼
5.  JOIN 조건으로 자주 사용되는 칼럼

</br></br>

## **인덱스 구조**

#### **1\. B-Tree 인덱스**

<img src="https://user-images.githubusercontent.com/64777557/226274852-fb92c011-363a-4fee-975b-d3b340fb4c36.png" width="700">

-   탐색 성능을 높이기 위해 균형 있게 높이를 유지하는 Balanced Tree의 일종
-   모든 리프 노드들은 같은 레벨에 있어야 함
-   데이터를 정렬된 순서로 저장하며 노드의 균형을 유지해 검색과 삽입, 삭제 작업을 빠르게 처리할 수 있음
-   노드는 키와 자식 노드를 가리키는 포인터의 쌍으로 이루어지며 각 노드는 여러 개의 키를 가질 수 있음

</br>

#### **2\. B+Tree 인덱스**

<img src="https://user-images.githubusercontent.com/64777557/226274883-26206c19-7605-4f80-821f-449a66a3a872.png" width="700">

-   B-Tree의 변형으로 B-Tree는 특정 데이터 검색은 효율적이지만 데이터 순회 시 모든 노드를 방문해야 한다는 단점 개선
-   리프 노드에만 데이터를 저장, 다른 노드에서는 자식 노드를 가리키는 포인터만 저장
-   리프 노드끼리는 연결리스트(Linked List)로 연결
-   리프 노드를 제외하고는 데이터를 저장하지 않기 때문에 메모리를 더 확보하여 더 많은 포인터를 담을 수 있어 검색 속도 향상
-   풀 스캔을 하는 경우 연결리스트로 연결되어 있는 리프 노드만 순회하면 되기 때문에 효율적
-   인덱스의 경우 부등호를 이용한 순차 검색 연산이 자주 발생하므로 B+Tree를 주로 사용

</br>

#### **3\. 해시 테이블(Hash Table)**

![image](https://user-images.githubusercontent.com/64777557/226274905-bfb16648-e7c0-46c8-ab70-fe8efeae1688.png)

-   key와 value를 한 쌍으로 데이터를 저장하는 자료구조
-   해시 함수는 값이 조금이라도 달라지면 완전히 다른 해시 값을 생성해 등호(=) 연산을 이용한 검색에 최적화 되어 있음
-   부등호(<, >) 연산이 자주 사용되는 검색을 위해서는 적합하지 않음
