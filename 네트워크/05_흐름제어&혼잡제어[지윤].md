## **흐름제어**

-   송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 기법
-   송신측의 전송량이 수신측의 처리량보다 클 경우 수신측의 큐가 용량을 넘어 전송된 패킷의 손실이 일어날 수 있기 때문에 송신측의 패킷 전송량을 제어함
-   수신측이 송신측에게 현재 자신의 상태를 피드백하는 형태

</br>

#### **1\. Stop and Wait**

![image](https://user-images.githubusercontent.com/64777557/216902930-e56cca47-ab7f-4a8a-9858-1c015103aa5d.png)
-   매번 전송한 패킷에 대해 확인 응답(ACK)을 받아야만 그 다음 패킷을 전송
-   구조 상 비효율적

</br>

#### **2\. Sliding Window**

-   수신측에서 설정한 윈도우 크기만큼 송신측에서 확인 응답 없이 패킷을 전송할 수 있게하여 데이터 흐름을 동적으로 조절
-   송신측은 먼저 윈도우에 포함되는 모든 패킷을 전송하고, 수신측으로부터 확인 응답(ACK)가 오면 윈도우를 옆으로 옮겨가며 다음 패킷들을 전송

![image](https://user-images.githubusercontent.com/64777557/216902963-1eee0ab6-e1bc-4205-b919-4e2f279ef062.png)

  **동작 방식**

-   송신측에서 \[0, 1, 2, 3, 4, 5, 6\]의 프레임을 전송할 수 있는 윈도우를 가지고 있음
-   먼저 0과 1을 전송했다고 가정하면 송신측의 슬라이딩 윈도우 구조는 \[2, 3, 4, 5, 6\]과 같이 축소
-   이때, 수신측으로부터 정상 수신을 알리는 ACK를 받았다면 송신측의 슬라이딩 윈도우는 해당 ACK의 프레임 수(\[0, 1\])만큼 오른쪽으로 윈도우의 경계를 확장
-   만약 송신측이 일정 시간동안 수신측으로부터 ACK를 받지 못한다면 패킷 재전송
-   송신측은 ACK와 함께 전달되는 수신측의 남은 버퍼 크기(윈도우 크기)를 바탕으로 전송량 제어

</br></br>

## **혼잡 제어**

-   송신측의 데이터 전달과 네트워크의 데이터 처리 속도 차이를 해결하기 위한 기법
-   네트워크의 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송속도를 제어함
    -   송신측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달되는데, 이때 한 라우터에 데이터가 몰려 모든 데이터를 처리할 수 없는 경우, 호스트들은 데이터를 재전송하게 되고 결국 혼잡만 가중시켜 오버플로우나 데이터 손실을 발생시킴
    -   네트워크 혼잡이란, 네트워크 내에 링크 대역폭 이상의 데이터가 전송되거나 네트워크 내의 패킷 수가 과도하게 증가하는 현상

</br>

![image](https://user-images.githubusercontent.com/64777557/216903242-708dedc9-00ae-42f3-8e08-9ffa87fb339f.png)

#### **1\. AIMD (Additive Increase/ Multicative Decrease, 합 증가/ 곱 감소)**

-   처음에는 패킷을 하나씩 전송 (Window Size = 1)
-   네트워크가 정상(ACK 수신 O)일 경우 Window Size + 1
-   네트워크가 혼잡(ACK 수신 X)한 경우 Window Size / 2
-   공편한 방식으로, 여러 호스트가 한 네트워크를 공유하고 있다면 나중에 진입한 쪽이 불리하겠지만, 시간이 흐르면서 평형 상태로 수렴하게 되는 특징
-   문제점은 초기에 네트워크의 높은 대역폭을 사용하지 못해 오랜 시간이 걸리고, 네트워크 혼잡 상황을 미리 감지하지 못하기 때문에 네트워크가 혼잡해지고 나서야 대역폭을 줄일 수 있는 방식임

</br>

#### **2\. Slow Start (느린 시작)**

-   처음에는 패킷을 하나씩 전송 (Window Size = 1)
-   네트워크가 정상(ACK 수신 O)일 경우 각각의 패킷 마다 Window Size + 1, 한 주기가 지나면 Window Size * 2가 됨 (지수적 증가)
-   네트워크가 혼잡(ACK 수신 X)한 경우 Window Size를 1로 줄임
-   AIMD 방식에 비해 처음 전송 속도를 올리는데 오랜 시간이 걸리지 않음

</br>

#### **3\. Congestion Avoidance (혼잡 회피)**

-   처음에는 네트워크 수용량을 예상하기 어렵지만 한번 혼잡이 발생하고 나면 그 이후에는 네트워크 수용량을 어느정도 예측할 수 있음
-   혼잡 현상이 발생하던 window size의 절반(임계값)까지는 이전처럼 지수 함수 꼴로 윈도우 크기를 증가시키고, 이후부터는 완만하게 1씩 증가
-   전송량이 임계값을 넘으면 Congestion Avoidance 단계로 진입하여 AIMD 방식으로 변환

</br>

#### **4\. Fast Retransmit (빠른 재전송)**

-   수신측에서 먼저 도착해야할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK 패킷을 전송함
-   단, 순서대로 잘 도착한 마지막 패킷의 다음 패킷 순번이 ACK 패킷과 함게 전송되므로 송신측은 손실된 패킷에 대해 순번이 중복된 ACK 패킷을 받게됨. 이를 인지하면 송신측은 해당 순번의 패킷을 재전송
-   중복된 순번의 패킷을 3개 받으면 재전송, 혼잡을 감지하고 window size 감소

</br>

#### **5\. Fast Recovery (빠른 회복)**

-   혼잡한 상태가 되면 window size를 1로 줄이지 않고 반으로 줄이고 선형증가시키는 방법
-   빠른 회복 정책까지 적용하면 혼잡 상황을 한번 겪고 나서부터는 순수한 AIMD 방식으로 동작
