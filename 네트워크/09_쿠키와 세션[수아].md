## 쿠키와 세션의 필요성
- HTTP의 약점을 보완하기 위해 사용 
  1. 비연결형(connectionless)
  2. 무상태(stateless)
- 통신이 1번 되면 서버와 클라이언트의 연결이 끊어지기 때문에 서버는 **클라이언트가 누구인지** 매번 인증해야 함 
- 이 번거로움을 해결하기 위해 `쿠키`와 `세션`을 사용 

</br>

## 쿠키(Cookie)
- `사용자에 의해 조작되어도 크게 문제되지 않을 정보를 브라우저(client)에 저장`
- 서버에서 사용자의 컴퓨터(client)에 저장하는 작은 기록 정보 파일 
- 필요할 때 정보 참조 or 재사용 가능 

![image](https://user-images.githubusercontent.com/63537847/218002800-0ec8f8cc-a433-4670-bdb8-687214609d42.png)


💡 **특징**  
1. 클라이언트에 총 300개의 쿠키 저장 가능
2. 1개의 도메인은 20개의 쿠키 가질 수 있음
3. 하나의 쿠키는 4KB까지 저장 가능 
4. 유효시간 동안은 브라우저가 종료되어도 인증이 유지됨 
5. Response Header에 Set-Cookie 속성을 사용하면 클라이언트에 쿠키를 만들 수 있음
6. 쿠키는 사용자가 따로 요청하지 않아도 브라우저가 Request시에 Request Header를 넣어서 자동으로 서버에 전송

📦 **구성 요소** 
1. 이름 : 각각의 쿠키 구별하는데 사용
2. 값 : 쿠키의 이름과 관련된 값
3. 유효시간(만료일) : 유지 기간
4. 도메인 : 쿠키 전송하는 도메인(서버)
5. 경로 : 전송 요청 경로 

🛠️ **동작 방식** 
1. 클라이언트가 페이지 요청
2. 서버는 쿠키 생성 
3. HTTP 헤더에 쿠키를 담아서 전송 (server → client) 
4. 클라이언트가 갖고 있다가(로컬 PC에 저장) 서버에 다시 요청할 때 요청과 쿠키를 함께 전송
5. 동일 사이트 재방문 시 클라이언트의 PC에 해당 쿠키가 있는 경우, 요청 페이지와 함께 쿠키를 전송
6. 서버에서 쿠키를 읽어 이전 상태 정보를 변경 할 필요가 있을 때 쿠키를 업데이트 하여 변경된 쿠키를 HTTP 헤더에 포함시켜 응답

✏️ **사용 예시**
- 방문 사이트에서 로그인 할 때 "아이디와 비밀번호를 저장하시겠습니까?"
- 팝업창 "오늘 이 창 다시 보지 않기"
- 쇼핑몰 장바구니 

</br>

## 세션(Session)
- 중요한 정보 관리 → 사용자가 직접 데이터를 수정할 수 없음 
- `인증에 대한 정보를 서버가 저장`
- 서버에서 클라이언트 구별하기 위해 session id 부여 후 브라우저가 서버에 접속해서 종료할 때까지 인증 상태 유지 
  - session id : 클라이언트가 Request를 보내면, 해당 서버의 엔진이 클라이언트에게 부여하는 유일한 ID
- 접속 시간에 제한을 두어 일정 시간 응답이 없다면 정보가 유지되지 않게 설정이 가능
- 쿠키보다 보안성 좋음
- 사용자가 많아질수록 서버 메모리를 많이 차지 (서버에 과부하 주어서 성능 저하의 요인이 됨) 

💡 **특징**  
1. 웹 서버에 웹 컨테이너의 상태를 유지하기 위한 정보 저장 
2. 각 클라이언트에게 고유 ID를 부여
3. 세션 ID로 클라이언트를 구분해서 클라이언트의 요구에 맞는 서비스를 제공
4. 보안 면에서 쿠키보다 우수 
5. 사용자가 많아질수록 서버 메모리를 많이 차지하게 됨
6. 저장 데이터의 제한 없음

🛠️ **동작 방식** 
1. 클라이언트가 페이지에 요청 
2. 서버는 접근한 클라이언트의 Request-Header 필드인 Cookie를 확인하여, 클라이언트가 해당 session-id를 보냈는지 확인
3. session-id가 존재하지 않는다면 서버는 session-id를 생성해 클라이언트에게 돌려줌
4. 서버에서 클라이언트로 돌려준 session-id를 쿠키를 사용해 서버에 저장
5. 클라이언트는 재접속 시, 이 쿠키를 이용해 session-id 값을 서버에 전달

✏️ **사용 예시**
- 화면을 이동해도 로그인이 풀리지 않고 로그아웃하기 전까지 유지

</br>

## 쿠키 vs 세션 
||쿠키(Cookie) |세션(Session) |
|---|---|---|
|정보 저장 위치|클라이언트(브라우저)|서버(서버의 자원 사용)|
|보안|변질되거나 request에서 스니핑 당할 우려가 있어서 보안에 취약|쿠키를 이용해서 session-id만 저장하고 그것으로 구분하여 서버에서 처리하기 때문에 비교적 보안성이 높음|
|라이프사이클|파일로 저장되어 브라우저 종료해도 정보 유지됨 </br> 만료기간 따로 지정해서 쿠키 삭제할 때까지 유지 가능|브라우저 종료되면 만료기간에 상관없이 삭제|
|속도|빠름(쿠키에 정보 있어서)|느림(정보가 서버에 있어서)|

### 세션보다 쿠키를 사용하는 이유는?
- 세션의 서버의 자원을 사용하기 때문에 자원에 한계가 있음
- 서버의 속도가 느려질 수 있기 때문에 쿠키와 세션을 적절한 요소 및 기능에 병행 사용
- 서버 자원의 낭비를 방지하며 웹사이트의 속도 ⬆️

</br>

# 토큰(Token)
- `인증에 대한 정보를 사용자가 저장`
- **등장 이유** : 
  - 시스템의 규모가 커짐에 따라 서버(세션) 기반 인증 방식의 한계 드러남
  - 웹/앱 어플리케이션이 발달하면서 서버 확장하기 어려워짐 

</br>

## 서버(세션) 기반 인증 방식 
![image](https://user-images.githubusercontent.com/63537847/218019262-9f5610ef-3e67-4e85-bc66-40dcf3f0fbb8.png)
- 서버 측에서 사용자의 정보를 기억해야 함 
- 사용자들의 정보를 기억하기 위해서는 세션 유지해야 함 
  - 메모리 or 디스크 or 데이터 베이스로 관리 
- `Stateful server` : 클라이언트의 상태를 계속해서 유지하고 이 정보를 서비스에 이용하는 역할의 서버 

🔴 **단점** 
1. 세션(Session)
  - 대부분 메모리에 세션 저장하는데 로그인 중인 사용자가 늘어나는 경우에는 RAM 과부하 
  - 데이터베이스에 저장하면 데이터베이스에 무리
2. 확장성(Extensibility)
  - 사용자가 늘어나면 여러 프로세스를 돌리거나 컴퓨터를 추가해야 함 (많은 트래픽 처리) 
  - 세션 분산하는 시스템 설게해야 하지만 매우 복잡 
3. CORS(Cross-Origin Resource Sharing)
  - 쿠키는 단일 도메인 및 서브 도메인에서만 작동 
  - 쿠키를 여러 도메인에서 관리하는 것이 어려움 


</br>

## 토큰(Token)
- 서버가 각각의 클라이언트를 구분하기 위해 발급하는 클라이언트의 정보를 담은 `암호화 데이터`
- 요즘에는 JWT(Json Web Token) 주로 사용 

## 토큰 기반 인증 방식
![image](https://user-images.githubusercontent.com/63537847/218019759-7538ecaf-675c-4d1b-a3bc-ec3c66d0f4ee.png)
- 인증받은 사용자들에게 토큰을 발급하고, 서버에 요청을 할 때 헤더에 토큰을 함께 보내도록 하여 유효성 검사 진행 
- 사용자의 인증 정보를 서버나 세션에 유지하지 않음
- 라이언트 측에서 들어오는 요청만으로 작업을 처리
- 상태를 유지하지 않으므로 `Stateless`한 구조

🛠️ **동작 방식** 
1. 사용자 로그인
2. 서버 측에서 클라이언트의 정보 검증
3. 정보 정확하면 서버가 사용자에게 `signed` 토큰 발급 
  - signed : 해당 토큰이 서버에서 정상적으로 발급된 토큰임을 증명 
4. 클라이언트는 서버에게서 받은 토큰을 저장 
5. 서버에 요청할 때마다 토큰을 함께 전달 (HTTP reuqest header에 토큰 포함)
6. 서버는 토큰 검증 후 요청 응답 

🔵 **장점** 
1. 무상태성(statless) & 확장성(Scalability)
  - 토큰은 클라이언트에 저장 ⇒ 서버는 stateless
  - 서버와 클라이언트의 연결고리가 없어서 확장하기 용이 
2. 보안성
  - 쿠키를 전달하지 않기 때문에 쿠키 사용에 의한 보안 취약점 ❌
  - BUT 토큰 환경 취약점에 대비해야 함
3. 확장성(Extensibility)
  - Extensibility : 로그인 정보가 사용되는 분야의 확장 
  - 토큰에 선택적인 권한만 부여하여 발급할 수 있음 
4. 여러 플랫폼 및 도메인 
  - CORS 해결 
  - 어떤 디바이스, 어떤 도메인에서도 토큰의 유효성 검사를 진행한 후에 요청을 처리 가능 

🔴 **단점** 
1. 토큰의 길이가 길어서 인증 요청이 많을수록 네트워크 부하가 오기 쉬움
2. payload 자체는 암호화되지 않아 사용자의 중요한 정보 저장 ❌
3. 토큰 탈취당하면 대처하기 어려움 


</br>
</br>

> 참고                    
> https://dev-coco.tistory.com/61        
> https://interconnection.tistory.com/74          
> https://mangkyu.tistory.com/55           
> https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-JWTjson-web-token-%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC#Token_%EC%9D%B8%EC%A6%9D
