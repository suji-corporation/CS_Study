## **HTTP (Hyper Text Transfer Protocol)**

</br>

<img src="https://user-images.githubusercontent.com/64777557/217150174-3b16641a-5c13-4d86-805e-eccd1d212e94.png" width=800>

-   웹 상에서 클라이언트와 서버 간에 요청(request)과 응답(response)으로 정보를 주고 받을 수 있는 프로토콜
-   TCP와 UDP 사용, 80번 포트 사용
-   **비연결**(Connectionless)
    -   클라이언트가 서버에게 요청을 보내고 서버가 적절한 응답을 클라이언트에게 보내면 연결이 바로 끊김
    -   간단하기 때문에 자원이 적게 든다는 장점
    -   동일한 클라이언트의 모든 요청에 대해 매번 새로운 연결과 해제의 과정을 거쳐야해 오버헤드가 발생단다는 단점
-   **무상태**(Stateless)
    -   연결을 끊는 순간 클라이언트와 서버의 통신은 끊기며 상태 정보를 유지하지 않음
    -   서버는 클라이언트를 식별할 수 없어 매번 인증 과정 필요
-   **단방향성**
    -   클라이언트의 요청 한 개에 대해 한 개의 응답을 보내는 방식이기 때문에 서버가 먼저 응답하지 않음

</br>

#### **HTTP의 문제점**

1.  암호화되지 않은 평문 통신이기 때문에 **도청** 가능
2.  통신 상대를 확인하지 않기 때문에 **위장** 가능
3.  데이터 무결성(완전성)을 증명할 수 없기 때문에 **변조** 가능

</br>

### **HTTP/1.x, HTTP2, HTTP3의 차이**

<img src="https://user-images.githubusercontent.com/64777557/217183375-72991cff-8e1d-4100-a919-6e2119aeaf26.png" width=500>

</br>

**HTTP/1.0**

-   한 연결당 하나의 요청을 처리하도록 설계
-   서버에게 요청 시 매번 연결과 해제의 과정을 반복해야 했기에 RTT가 오래걸린다는 문제
    -   RTT: 패킷이 목적지에 도달하고 나서 다시 출발지로 돌아오기까지 걸리는 시간 (패킷 왕복 시간)

</br>

**HTTP/1.1**

-   Persistent Connection 추가
    -   HTTP/1.0을 보완하여 매번 TCP 연결을 하는 것이 아니라 한 번 TCP 초기화를 한 이후에 keep-alive라는 옵션으로 일정 시간동안 연결 상태를 유지

<img src="https://user-images.githubusercontent.com/64777557/217183417-7eb3a5ef-fe56-433d-9b0d-89c1287c811a.png" width=500>

-   Pipelining 추가
    -   TCP의 특성상 요청 후 응답을 기다려야하는 문제를 보완
    -   클라이언트는 앞 요청의 응답을 기다리지 않고 순차적으로 요청 전송, 서버는 요청이 들어온 순서대로 응답

<img src="https://user-images.githubusercontent.com/64777557/217183448-b5774cb8-1549-4ab0-a25d-a821f1ab638e.png" width=500>

-   HOL Blocking (Head Of Line Blocking) 문제
    -   앞의 요청(패킷)에 대한 응답이 늦어지면 뒤의 모든 요청들은 모두 blocking되어 응답이 지연됨
-   연속된 요청 간에 헤더의 많은 중복이 생긴다는 문제

</br>

**HTTP/2.0**

-   HTTP/1.x의 시간 지연 문제를 해결
-   Multiplexed streams (멀티플렉싱)
    -   HTTP/1.1의 Pipelining은 한번의 연결에서 여러 요청을 보낼 수는 있었지만 동시에 여러 요청을 처리하진 못했음
    -   하나의 커넥션 내에 여러개의 스트림(stream, 양방향 데이터 흐름)을 사용하여 송수신
    -   메시지가 이진화된 텍스트인 프레임(frame)으로 나뉘어 요청마다 구분되는 스트림(stream)을 통해 전달
    -   프레임(frame)이 각 요청의 스트림(stream)을 통해 전달되며, 하나의 커넥션 안에 여러개의 스트림(stream)을 가질 수 있게되어 다중화(multiplexing)가 가능해짐
    -   스트림(stream)을 통해 각 요청의 응답  순서가 의미가 없어져 HTTP/1.x의 HOL Blocking 문제 해결

<img src="https://user-images.githubusercontent.com/64777557/217182702-f83014fe-943f-4f38-9ed5-3692aaa0b55e.png" width=600>

-   Header Compression (헤더 압축)
    -   요청과 응답 헤더의 메타데이터를 압축해서 기존의 연속된 요청에서의 중복 헤더로 인한 오버헤드 문제를 해결
    -   이전에 표시된 헤더를 제외한 필드를 허프만 코딩을 활용해서 압축
-   Server Push (서버 푸시)
    -   클라이언트가 서버에 요청하지 않아도 클라이언트에게 필요한 리소스를 서버가 추가적으로 push해주는 기능
-   각 요청마다 stream으로 구분해 병렬적으로 처리함에도 불구하고 TCP 고유의 HOL Blocking이 여전히 존재하는 문제
    -   서로 다른 stream이 전송되고 있을 때, 하나의 Stream에서 유실이 발생되거나 문제가 생기면 결국 다른 Stream도 문제가 해결될 때 까지 지연되는 현상이 발생

</br>

**HTTP/3.0**

-   TCP 위에서 돌아가는 HTTP/2.0와는 달리 QUIC라는 계층 위에서 돌아가며 TCP기반이 아닌 UDP 기반
-   HTTP/2.0의 장점(멀티플렉싱 등)의 기능을 가지고 있음
-   초기 연결 설정 시 지연 시간 감소라는 대표적 특징 (UTP기반)
    -   초기 연결(통신 시작) 시 3-way handshaking 과정을 거치지 않아 1-RTT만 소요
    -   클라이언트와 서버거 한번 신호를 주고받은 후 바로 통신 시작
-   TCP의 stream은 하나의 chain으로 연결되는 것과 달리 각 stream당 독립된 stream chain을 구성하여 TCP의 HOL Blocking을 해결


</br></br>

## **HTTPS (Hyper Text Transfer Protocol Secure)**

</br>

<img src="https://user-images.githubusercontent.com/64777557/217150209-bb11280b-225b-476f-b842-83cdef590257.png" width=800>

-   HTTP에서 데이터 암호화, 인증, 무결성(완전성) 보호가 더해진 프로토콜
-   기본 TCP/IP 포트로 443번 포트 사용
-   소켓 통신에서 일반 텍스트를 이용하는 대신, 웹 상에서 정보를 암호화하는 SSL이나 TLS 프로토콜을 통해 세션 데이터를 암호화하여 사용
    -   SSL(Secure Socket Layer)과 TLS(Transport Layer Security) 프로토콜의 주요 목표는 기밀성, 데이터 무결성, ID 및 디지털 인증서를 사용한 인증을 제공하는 것

</br>

#### **HTTPS가 필요한 이유**

  클라이언트인 웹 브라우저가 HTTP를 통해 서버에  웹 페이지 정보를 요청하면 서버는 해당 요청에 대한 응답으로 요구한 정보를 제공한다.
  이때 웹 페이지(HTML)은 텍스트 정보가 되는데, 개인정보와 같이 민감한 정보가 포함된 텍스트 정보를 주고받을 때 제 3자가 네트워크 상에서 중간에 정보를 가로챈다면 보안상 큰 문제가 발생할 수 있다.
  따라서, 중간에 정보가 가로채지더라도 해당 정보를 알아볼 수 없도록 암호화하는 방법인 HTTPS 프로토콜이 필요하다.

</br>

#### **HTTPS의 원리 (SSL 통신 과정)**

  대칭키(세션키) 암호화와 비대칭키 암호화를 모두 사용하여 빠른 연산 속도와 안정성을 갖고 있다.

1.  클라이언트가 서버로 최조 연결 시도
2.  서버는 공개키(인증서)를 클라이언트로 전송
3.  클라이언트는 인증서의 유효성을 검사하고 세션키를 발급
4.  클라이언트는 세션키를 보관하며 추가로 서버의 공개키로 세션키를 암호화하여 서버로 전송
5.  서버는 개인키로 암호화된 세션키를 복호화하여 세션키를 얻음
6.  클라이언트와 서버는 동일한 세션키를 공유하므로 데이터 전달 시 세션키로 암복호화 진행

</br></br>

## **HTTP와 HTTPS**

  HTTP는 암호화 과정 없이 데이터를 전달하기 때문에 보안에 취약한 반면, HTTPS는 암호화로 네트워크 상에서 열람 및 수정이 불가능해 안전하다.
  하지만 HTTPS는 암호화하는 과정이 웹 서버에 부하를 주고, 설치 및 인증서를 유지하는데 추가 비용이 발생하며, HTTP에 비해 느리다는 단점이 있다.
  또한, HTTPS의 경우에는 소켓 자체에서 인증 과정이 있기 때문에 인터넷 연결이 끊기면 소켓도 끊어져 재인증하는 시간이 소요된다. 

결론적으로는 개인정보와 같이 민감한 데이터를 주고 받을 경우에는 HTTPS를 반드시 이용해야하고, 노출되어도 상관없는 단순한 정보 조회만을 처리한다면 HTTP를 이용해도 된다.
