## **쿠키(Cookie)**

-   **개념**
    -   클라이언트 로컬 스토리지에 저장되는 키(key)와 값(value)이 들어있는 파일
    -   클라이언트의 상태 정보를 브라우저에 저장하여 참조
    -   아이디/비밀번호 저장, 쇼핑몰 장바구니 등에 사용
-   **구성 요소**
    -   쿠키의 이름 (name)
    -   쿠키의 값 (value)
    -   쿠키의 만료 시간 (Expires)
    -   쿠키를 전송할 도메인 이름 (Domain)
    -   쿠키를 전송할 경로 (Path)
    -   보안 연결 여부 (Secure)
    -   HttpOnly 여부 (HttpOnly)
-   **동작 방식**

<img src="https://user-images.githubusercontent.com/64777557/218026490-e6af3986-ba2f-42b7-84fe-1fbf15167d2f.png" width=800>


1.  클라이언트(브라우저)가 서버에게 요청
2.  서버는 상태를 유지하고 싶은 데이터(user)를 쿠키로 생성
3.  서버가 클라이언트에게 응답을 보낼 때 HTTP헤더(set-cookie)에 쿠키를 포함하여 전송 \[set-cookie: user=jiyun\]
4.  전달 받은 쿠키는 클라이언트(브라우저)에서 관리하다가 다시 서버에 요청 시 해당 쿠키를 HTTP헤더에 넣어 전송 \[cookie: user=jiyun\]
5.  서버는 쿠키 정보를 읽고 상태 정보를 확인한 후 응답

</br></br>

## **세션(Session)**

-   **개념**
    -   일정 시간동안 같은 클라이언트로부터 들어오는 요청을 하나의 상태로 보고 그 상태를 유지하는 기술
    -   웹 브라우저를 통해 서버에 접속한 이후부터 브라우저가 종료될 때까지 유지
    -   로그인과 같은 보안상 중요한 작업 수행 시 사용
-   **동작 방식**

<img src="https://user-images.githubusercontent.com/64777557/218026528-3db55fe3-f095-4b6b-9cbd-6ac7cd35f5eb.png" width=800>


1.  클라이언트(브라우저)가 서버에 요청
2.  서버는 클라이언트 구분을 위해 클라이언트(브라우저)에 유일한 세션 ID를 부여
3.  서버가 응답 시 HTTP헤더(set-cookie)에 세션 ID를 포함해서 전송 \[set-cookie: sessionId:x1r2fjc0\]
4.  클라이언트는 세션 ID에 대한 정보를 쿠키로 관리
5.  이후 클라이언트(브라우저)에서 서버로 요청 시 세션 ID가 담겨있는 쿠키를 HTTP헤더에 넣어 전송 \[cookie: sessionId:x1r2fjc0\]
6.  서버는 세션 ID를 확인한 후 요청을 처리

</br></br>

## **쿠키(Cookie) VS 세션(Session)**

|   | 쿠키(Cookie) | 세션(Session) |
| --- | --- | --- |
| 저장 위치 | 클라이언트 (접속자 PC 브라우저) | 웹 서버 |
| 저장 형식 | text | Object |
| 만료 시점 (라이프사이클) | 쿠키 저장 시 설정   ( 브라우저가 종료되어도 만료기간이 남아있다면 삭제되지 않음) | 브라우저 종료 시 삭제   (만료기간을 설정할 수 있지만 브라우저 종료 시 이와 상관없이 삭제) |
| 사용하는 자원(리소스) | 클라이언트 리소스 | 웹 서버 리소스 |
| 용량 제한 | 총 300개 / 한 도메인 당 20개 / 한 쿠키 당 4KB | 서버가 허용하는 한 용량 제한 없음 |
| 속도 | 클라이언트에 저장되어 빠름 | 서버가 처리하여 쿠키보다 느림 |
| 보안 | 모든 정보가 클라이언트가 저장되어 보안에 취약 | 클라이언트에는 세션ID만 저장하여 보안성이 좋음 |

</br>

**※ 세션이 보안 차원에서도 좋은데 쿠키를 사용하는 이유**

  세션은 서버의 자원을 사용하기 때문에 너무 많이 만들거나 사용자가 많아질 경우 서버의 메모리가 감당할 수 없어지고 이에 따라 속도가 느려질 수 있다.
  
 </br></br>
  
  ## **토큰(Token) 기반 인증**

-   클라이언트가 서버에 접속 시 서버에서 해당 클라이언트에게 인증의 의미로 '토큰'을 부여 -> **인증(Authentication)**
-   클라이언트는 또 다시 서버에 요청을 보낼 때 발급받은 토큰을 요청 헤더에 심어 전송
-   서버는 헤더 내 토큰을 열어 자신이 제공한 토큰이 맞는지 확인하여 인증 과정 처리 -> **인가(Authorization)**

> 💡**용어 정리**  
> \- **인증(Authentication)**: 자신이 누구인지 증명하고 검증하는 과정 (로그인)  
> \- **인가(Authorization)**: 인증 작업 이후에 인증된 사용자에 대한 자원 접근 확인 및 허가 절차 (권한 확인)

-   **장점**
    -   토큰 정보를 클라이언트 측에서 저장하기 때문에 stateless(무상태)하며, 서버 확장에 용이 (서버 부담 X)
    -   토큰은 한 번 발급되면 유효기간이 만료될 때까지 계속 사용 가능
    -   토큰에는 기본 정보, 전달할 정보, 토큰이 검증되었다는 서명 등 필요한 모든 정보를 자체적으로 지니고 있음
    -   header와 payload를 가지고 signature을 생성하므로 데이터 위변조 방지
-   **단점**
    -   쿠키/세션과 다르게 토큰 자체의 데이터 길이가 길어, 인증 요청이 많아질수록 네트워크 부하 발생
    -   Payload 자체는 암호화되지 않기 때문에 유저의 중요한 정보는 담을 수 있음
    -   토큰을 탈취 당할 경우 대처가 어려움

</br>

### **토큰 인증 과정**

![image](https://user-images.githubusercontent.com/64777557/218026980-4ddd35ef-764f-49c4-a8fd-93f4dedd7cef.png)

1.  사용자가 아이디와 비밀번호로 로그인
2.  서버는 클라이언트(사용자)에게 토큰을 발급
3.  클라이언트는 서버 측에서 전달받은 토큰을 쿠키나 스토리지에 저장
4.  서버에 요청 시마다 해당 토큰을 HTTP 요청 헤더에 포함시켜 전달
5.  서버는 전달받은 토큰을 검증하고, 요청에 응답

</br>

### **JWT (JSON Web Token)**

<img src="https://user-images.githubusercontent.com/64777557/218027055-4183625f-1dd3-4a04-ac76-067e5c72254a.png" width=700>

-   인증에 필요한 정보들을 암호화시킨 JSON 토큰을 의미
-   JWT 토큰은 점(.)으로 구분된 Header, Payload, Signature로 구성
    1.  **Header(헤더)**: 보통 토큰의 타입이나 서명 생성에 어떤 알고리즘이 사용되었는지 저장
    2.  **Payload(내용)**:  사용자 권한 정보와 실제로 사용될 정보(JWT를 통해 알 수 있는 데이터)를 저장
    3.  **Signature(서명)**: 'Header+Payload'와 서버가 가지고 있는 유일한 Key값을 헤더에서 정의한 알고리즘으로 암호화한 값 (비대칭 암호화) -> Authorization(인가) 작업으로 토큰의 유효성 검증 시 사용

</br></br>

## **서버(세션) 기반 인증**

![image](https://user-images.githubusercontent.com/64777557/218027077-bf950087-946d-4e98-b963-a20c14f9f370.png)

-   클라이언트가 서버에 접속 시 서버는 클라이언트(사용자)의 정보를 서버의 세션 저장소에 저장 후 세션ID 발급 \-> **인증(Authentication)**
-   클라이언트는 또 다시 서버에 요청을 보낼 때 발급받은 세션ID을 요청 헤더와 함께 전송
-   서버는 헤더 내 세션ID를 통해 세션 저장소에 접근한 후 세션ID에 해당하는 세션 정보가 존재하는지 확인하여 인증 과정 처리 \-> **인가(Authorization)**

-   **장점**
    -   모든 인증 정보를 서버에서 관리하기 때문에 보안성이 높음 
-   **단점**
    -   서버 측 (세션 저장소)에서 정보가 저장되므로 요청이 많아지면 서버 부하가 심해짐
    -   공격자가 세션ID를 탈취하여 정상 클라이언트인 척 위장 가능 
    -   서버 확장 시 세션 분산 작업이 어려움
